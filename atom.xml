<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timei.me/atom.xml" rel="self"/>
  
  <link href="https://timei.me/"/>
  <updated>2025-01-05T06:08:48.437Z</updated>
  <id>https://timei.me/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>十大经典排序算法</title>
    <link href="https://timei.me/2025/01/05/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://timei.me/2025/01/05/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2025-01-05T06:01:04.000Z</published>
    <updated>2025-01-05T06:08:48.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://imgs.cloves.top/2025/01/b3345cf9d43747e68766862986f077d1.png" alt="suanfa"></p><h3 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h3><p><img src="https://imgs.cloves.top/2025/01/fc109738981932bd194e176812dce9ad.png" alt="duibi"></p><p>关于稳定性</p><p>稳定的排序算法：冒泡排序、插入排序、快速排序、归并排序、桶排序、计数排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><h3 id="冒泡，选择，插入排序"><a href="#冒泡，选择，插入排序" class="headerlink" title="冒泡，选择，插入排序"></a>冒泡，选择，插入排序</h3><p>简单直观的排序算法</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><h5 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h5><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h5 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h5><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p><strong>希尔排序的基本思想是</strong>：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</p><p>按增量序列个数 k，对序列进行 k 趟排序；</p><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h4 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://imgs.cloves.top/2025/01/f9616f6892819e579a2d4ab10256a732.gif" alt="dt1"></p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</p><p>选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h4 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://imgs.cloves.top/2025/01/9541d116b9ad191437cb0f9acce7baf6.gif" alt="dt2"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><h4 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://imgs.cloves.top/2025/01/71c0f1c0ceb0e053c423426e7f343602.gif" alt="dt3"></p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序：是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。</p><p>堆(Heap)是计算机科学中一类特殊的数据结构的统称。</p><p>堆通常是一个可以被看做一棵完全二叉树的数组对象。</p><p>堆满足下列性质：</p><ul><li>堆中某个节点的值总是不大于或不小于其父节点的值。</li><li>堆总是一棵完全二叉树。</li></ul><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><h4 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://imgs.cloves.top/2025/01/658d0f58eed41a5c11cd1d1c039269ba.gif" alt="dt4"></p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序<strong>不是</strong>基于比较的排序算法。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序的特征</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。</p><h4 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>（1）找出待排序的数组中最大和最小的元素</li><li>（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://imgs.cloves.top/2025/01/827d96b8ca3682e8775f4916f22b45ac.gif" alt="dt5"></p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><ol><li>什么时候最快</li></ol><p>​ 当输入的数据可以均匀的分配到每一个桶中。</p><ol start="2"><li><p>什么时候最慢</p><p>当输入的数据被分配到了同一个桶中。</p></li></ol><h4 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p>元素分布在桶中：</p><p><img src="https://imgs.cloves.top/2025/01/db29e7423ceb2744e560cd81b56b81be.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="https://imgs.cloves.top/2025/01/6b4c5e9445b9741af718e69de82ce0fe.png" alt="img"></p><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序：是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h4 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h4><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h4 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h4><p><img src="https://imgs.cloves.top/2025/01/6690b1054909755ffcca96feb7a4d3ec.gif" alt="dt6"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://imgs.cloves.top/2025/01/b3345cf9d43747e68766862986f0</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java 主流锁</title>
    <link href="https://timei.me/2024/12/06/java%E4%B8%BB%E6%B5%81%E9%94%81/"/>
    <id>https://timei.me/2024/12/06/java%E4%B8%BB%E6%B5%81%E9%94%81/</id>
    <published>2024-12-06T06:31:13.000Z</published>
    <updated>2024-12-06T06:32:53.656Z</updated>
    
    <content type="html"><![CDATA[<p>基于对象的原生锁——synchronized</p><p>实际上，Java 在<code>java.util.concurrent</code>（JUC）包下，还为我们提供了更多的锁类和锁接口（尤其是子包 locks 下），它们有更强大的功能或更牛逼的性能。</p><p>来看看<code>synchronized</code>的不足之处吧。</p><ul><li>如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，<strong>同一时间只能有一个线程执行</strong>。</li><li>synchronized 无法知道线程有没有成功获取到锁。</li><li>使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li></ul><blockquote><p>临界区（Critical Section）是多线程中一个 非常重要的概念，指的是在代码中访问共享资源的那部分，且同一时刻只能有一个线程能访问的代码。多个线程同时访问临界区的资源如果没有任何同步（加锁）操作，会导致资源的状态不可预测和不一致，从而产生所谓的“竞态条件”(Race Condition)。在许多并发控制策略中，例如互斥锁 synchronized，目标就是确保任何时候只有一个线程进入临界区。</p></blockquote><p>​synchronized 的这些不足之处都可以通过 JUC 包下的其他锁来弥补</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="https://imgs.cloves.top/2024/12/c1108590c9b36555c13c9114731207a7.png" alt="fenlei"></p><h3 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java 中，<strong>synchronized</strong> 关键字 是最典型的悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候会去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在 Java 中是通过无锁编程来实现的，最常采用的是<a href="https://javabetter.cn/thread/cas.html">CAS 算法</a>，<a href="https://javabetter.cn/thread/atomic.html">Java 原子类</a>的递增操作就通过 CAS 自旋实现的。</p><p><img src="https://imgs.cloves.top/2024/12/3b19b9c0b4848c6765e1ba734e891ad6.png" alt="duibi"></p><p>根据上面的概念描述我们可以发现：</p><ul><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p></li><li><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"><span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPublicResources</span><span class="params">()</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  </span><br><span class="line"><span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式的举例，我们发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</p><p>我们这里<strong>简单</strong>了解一下 “CAS” 的技术原理</p></li></ul><p>​CAS 是一种无锁算法，可以在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。JUC 包中的<a href="https://javabetter.cn/thread/atomic.html">原子类</a>  ， 就是通过 CAS 实现的乐观锁。</p><p>CAS 算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>CAS 虽然高效，但也存在三大问题</p><ol><li>ABA 问题</li></ol><p>​所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类<code>AtomicStampedReference</code>类来解决 ABA 问题。</p><p>这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用 CAS 设置为新的值和标志。</p><p>2.长时间自旋</p><p>   CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p><p>   解决思路是让 JVM 支持处理器提供的<strong>pause 指令</strong>。</p><p>   pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p><p>3.### 多个共享变量的原子操作</p><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，这时通常有两种做法：</p><ul><li><p>使用<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</p></li><li><p>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</p></li></ul><h3 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h3><p>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程花费的时间可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否会很快释放锁。</p><p>为了让当前线程“稍等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不用阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="https://imgs.cloves.top/2024/12/348282a809b0f6d93dcc93294d4738b4.png" alt="zixuan"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是 10 次）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p>JDK 6 中，引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着 自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功的，进而它将允许自旋等待更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁,偏向锁,轻量级锁,重量级锁"></a>无锁,偏向锁,轻量级锁,重量级锁</h3><p>其实就是synchronized 的四种锁状态</p><p>在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入synchronized块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。、</p><p>这也是为什么很多开发者会认为 synchronized 性能很差的原因。</p><p>那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了“偏向锁”和“轻量级锁” 的概念，对 synchronized 做了一次重大的升级，升级后的 synchronized 性能可以说上了一个新台阶。</p><p>在 JDK 1.6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li><p>无锁状态</p></li><li><p>偏向锁状态</p></li><li><p>轻量级锁状态</p></li><li><p>重量级锁状态</p><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，很好理解。</p></li></ol><table><thead><tr><th align="left"><strong>锁</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left">偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td align="left">轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td align="left">重量级锁</td><td>线程竞争不使用自旋，不会消耗 CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句</strong>,CAS操作都不做了，着极大地提高了程序的运行性能。</p><p>大白话就是对锁设置个变量，如果发现为 true，代表资源无竞争，则无需再走各种加锁&#x2F;解锁流程。如果为 false，代表存在其他线程竞争资源，那么就会走后面的流程。</p><h4 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h4><p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于对象的原生锁——synchronized&lt;/p&gt;
&lt;p&gt;实际上，Java 在&lt;code&gt;java.util.concurrent&lt;/code&gt;（JUC）包下，还为我们提供了更多的锁类和锁接口（尤其是子包 locks 下），它们有更强大的功能或更牛逼的性能。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://timei.me/2024/11/16/Redis/"/>
    <id>https://timei.me/2024/11/16/Redis/</id>
    <published>2024-11-16T01:31:13.000Z</published>
    <updated>2024-12-02T12:16:59.656Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、<strong>缓存</strong>和消息中<br>间件。 它支持多种类型的数据结构</p><h3 id="缓存（Cache）的概念"><a href="#缓存（Cache）的概念" class="headerlink" title="缓存（Cache）的概念"></a>缓存（Cache）的概念</h3><p>缓存是存储在计算机上的一个原始数据复制集，以便于访问。</p><p><img src="https://imgs.cloves.top/2024/12/c0ebffe5911879e22cc2c7c0c18c0cf8.png" alt="img-缓存的概念"></p><h3 id="缓存命中率的一些概念"><a href="#缓存命中率的一些概念" class="headerlink" title="缓存命中率的一些概念"></a>缓存命中率的一些概念</h3><p><img src="https://imgs.cloves.top/2024/12/78407704303ec5ec7ddd9f43bc94981c.png" alt="img-cache"></p><h3 id="Redis的命令"><a href="#Redis的命令" class="headerlink" title="Redis的命令"></a><strong>Redis的命令</strong></h3><ul><li>指定database  select 0</li></ul><h4 id="操作Key"><a href="#操作Key" class="headerlink" title="操作Key"></a>操作Key</h4><ul><li>exists 查询key是否存在</li><li>keys 查询是否存在指定的key</li><li>type 查询key的数据类型</li><li>scan 扫描当前库中所有的key</li></ul><h4 id="操作String"><a href="#操作String" class="headerlink" title="操作String"></a>操作String</h4><ul><li>set :添加一条String类型数据</li><li>get :获取一条String类型数据</li><li>mset :添加多条String类型数据</li><li>mget :获取多条String类型数据</li><li>incr :增加1</li><li>decr：减少1</li></ul><h4 id="操作hash"><a href="#操作hash" class="headerlink" title="操作hash"></a>操作hash</h4><ul><li>hset :添加一条hash类型数据</li><li>hget :获取一条hash类型数据</li><li>hmset :添加多条hash类型数据</li><li>hmget :获取多条hash类型数据</li><li>hgetAll :获取指定所有hash类型数据</li><li>hdel :删除指定hash类型数据(一条或多条)</li></ul><h4 id="操作list"><a href="#操作list" class="headerlink" title="操作list"></a>操作list</h4><ul><li><p>lpush :左添加(头)list类型数据</p></li><li><p>rpush :右添加(尾)类型数据</p></li><li><p>lrange : 获取list类型数据start起始下标 end结束下标 包含关系</p></li><li><p>llen :获取条数</p></li><li><p>lrem :删除列表中几个指定list类型数据</p><ul><li><pre><code class="TEXT">lrem key count valuecount &gt; 0 从前向后删除count个valuecount &lt;0 从后向前删除 绝对值（count） 个valuecount = 0 删除所有的value</code></pre></li></ul></li></ul><h4 id="操作set"><a href="#操作set" class="headerlink" title="操作set"></a>操作set</h4><ul><li>sadd :添加set类型数据</li><li>smembers :获取set类型数据</li><li>scard :获取条数</li><li>srem :删除数据</li></ul><h4 id="操作sorted-set"><a href="#操作sorted-set" class="headerlink" title="操作sorted set"></a>操作sorted set</h4><p>sorted set是通过分数值来进行排序的，分数值越大，越靠后。</p><ul><li><p>zadd :添加sorted set类型数据</p><p>zadd需要将Float或者Double类型分数值参数，放置在值参数之前</p></li><li><p>zrange :获取sorted set类型数据</p></li><li><p>zcard :获取条数</p></li><li><p>zrem :删除数据</p></li></ul><h4 id="操作namespace"><a href="#操作namespace" class="headerlink" title="操作namespace"></a>操作namespace</h4><ul><li><p>mset 添加数据   例  mset user:01 zhangsan</p></li><li><p>mget 获取数据    例 mget  user:01</p></li></ul><h4 id="操作失效时间"><a href="#操作失效时间" class="headerlink" title="操作失效时间"></a>操作失效时间</h4><ul><li><p>EXPLRE 简写 EX  ex &lt;key&gt; &lt;ttl&gt;  用于生成键的同时设置生存时间（秒）</p><p>例 set  code test EX 180</p></li><li><p>PEXPIRE &lt;key&gt;  &lt;ttl&gt; 可以将 已有的键 key 的过期时间设置为 <strong>毫秒</strong> 不加 P 是秒</p><p>例  pexpire  code 1000</p></li><li><p>NX 是key不存在时才set，防止覆盖    XX 是key存在时才set，不创建新的key</p><p> EX 是秒， PX 是毫秒     例 set  code  test  nx  ex 180</p></li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>del :用于删除数据（通用，适用于所有数据类型）</li><li>hdel :用于删除hash类型数据</li></ul><h3 id="Redis的事务机制"><a href="#Redis的事务机制" class="headerlink" title="Redis的事务机制"></a>Redis的事务机制</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程<br>中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h4 id="事务的操作命令"><a href="#事务的操作命令" class="headerlink" title="事务的操作命令"></a>事务的操作命令</h4><p>Multi、Exec、discard</p><p>输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行。<br>输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。</p><h4 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h4><p>组队阶段某个命令出现了报告错误，执行时整个的所有队列会都会被取消。<br>执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><h3 id="Redis的高可用"><a href="#Redis的高可用" class="headerlink" title="Redis的高可用"></a>Redis的高可用</h3><p>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群。</p><h4 id="数据的持久化（数据落盘）"><a href="#数据的持久化（数据落盘）" class="headerlink" title="数据的持久化（数据落盘）"></a>数据的持久化（数据落盘）</h4><h5 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h5><p>  会损失较长时间的数据（分钟级别）</p><h5 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h5><p>  会损失1秒钟的数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、&lt;strong&gt;缓存&lt;/strong&gt;和消息中&lt;br&gt;间件。 它支持多种类型的数据结构&lt;/p&gt;
&lt;h3 id=&quot;缓存（Cache）的概念&quot;&gt;&lt;a href=&quot;#缓存（Cache）的概念&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://timei.me/2024/11/15/hello-world/"/>
    <id>https://timei.me/2024/11/15/hello-world/</id>
    <published>2024-11-15T14:11:23.805Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
