<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timei.me/atom.xml" rel="self"/>
  
  <link href="https://timei.me/"/>
  <updated>2024-12-06T06:32:53.656Z</updated>
  <id>https://timei.me/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 主流锁</title>
    <link href="https://timei.me/2024/12/06/java%E4%B8%BB%E6%B5%81%E9%94%81/"/>
    <id>https://timei.me/2024/12/06/java%E4%B8%BB%E6%B5%81%E9%94%81/</id>
    <published>2024-12-06T06:31:13.000Z</published>
    <updated>2024-12-06T06:32:53.656Z</updated>
    
    <content type="html"><![CDATA[<p>基于对象的原生锁——synchronized</p><p>实际上，Java 在<code>java.util.concurrent</code>（JUC）包下，还为我们提供了更多的锁类和锁接口（尤其是子包 locks 下），它们有更强大的功能或更牛逼的性能。</p><p>来看看<code>synchronized</code>的不足之处吧。</p><ul><li>如果临界区是只读操作，其实可以多线程一起执行，但使用 synchronized 的话，<strong>同一时间只能有一个线程执行</strong>。</li><li>synchronized 无法知道线程有没有成功获取到锁。</li><li>使用 synchronized，如果临界区因为 IO 或者 sleep 方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li></ul><blockquote><p>临界区（Critical Section）是多线程中一个 非常重要的概念，指的是在代码中访问共享资源的那部分，且同一时刻只能有一个线程能访问的代码。多个线程同时访问临界区的资源如果没有任何同步（加锁）操作，会导致资源的状态不可预测和不一致，从而产生所谓的“竞态条件”(Race Condition)。在许多并发控制策略中，例如互斥锁 synchronized，目标就是确保任何时候只有一个线程进入临界区。</p></blockquote><p>​synchronized 的这些不足之处都可以通过 JUC 包下的其他锁来弥补</p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="https://imgs.cloves.top/2024/12/c1108590c9b36555c13c9114731207a7.png" alt="fenlei"></p><h3 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p><p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java 中，<strong>synchronized</strong> 关键字 是最典型的悲观锁。</p><p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候会去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p><p>乐观锁在 Java 中是通过无锁编程来实现的，最常采用的是<a href="https://javabetter.cn/thread/cas.html">CAS 算法</a>，<a href="https://javabetter.cn/thread/atomic.html">Java 原子类</a>的递增操作就通过 CAS 自旋实现的。</p><p><img src="https://imgs.cloves.top/2024/12/3b19b9c0b4848c6765e1ba734e891ad6.png" alt="duibi"></p><p>根据上面的概念描述我们可以发现：</p><ul><li><p>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</p></li><li><p>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</p><p>光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"><span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modifyPublicResources</span><span class="params">()</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line"><span class="comment">// 操作同步资源</span></span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  </span><br><span class="line"><span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure><p>通过调用方式的举例，我们发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</p><p>我们这里<strong>简单</strong>了解一下 “CAS” 的技术原理</p></li></ul><p>​CAS 是一种无锁算法，可以在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。JUC 包中的<a href="https://javabetter.cn/thread/atomic.html">原子类</a>  ， 就是通过 CAS 实现的乐观锁。</p><p>CAS 算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>CAS 虽然高效，但也存在三大问题</p><ol><li>ABA 问题</li></ol><p>​所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类<code>AtomicStampedReference</code>类来解决 ABA 问题。</p><p>这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用 CAS 设置为新的值和标志。</p><p>2.长时间自旋</p><p>   CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p><p>   解决思路是让 JVM 支持处理器提供的<strong>pause 指令</strong>。</p><p>   pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p><p>3.### 多个共享变量的原子操作</p><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，这时通常有两种做法：</p><ul><li><p>使用<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</p></li><li><p>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</p></li></ul><h3 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h3><p>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复线程花费的时间可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃 CPU 的执行时间，看看持有锁的线程是否会很快释放锁。</p><p>为了让当前线程“稍等一下”，我们需要让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不用阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><p><img src="https://imgs.cloves.top/2024/12/348282a809b0f6d93dcc93294d4738b4.png" alt="zixuan"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是 10 次）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是 CAS，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><p>JDK 6 中，引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应意味着 自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功的，进而它将允许自旋等待更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p><h3 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁,偏向锁,轻量级锁,重量级锁"></a>无锁,偏向锁,轻量级锁,重量级锁</h3><p>其实就是synchronized 的四种锁状态</p><p>在 JDK 1.6 以前，所有的锁都是”重量级“锁，因为使用的是操作系统的互斥锁，当一个线程持有锁时，其他试图进入synchronized块的线程将被阻塞，直到锁被释放。涉及到了线程上下文切换和用户态与内核态的切换，因此效率较低。、</p><p>这也是为什么很多开发者会认为 synchronized 性能很差的原因。</p><p>那为了减少获得锁和释放锁带来的性能消耗，JDK 1.6 引入了“偏向锁”和“轻量级锁” 的概念，对 synchronized 做了一次重大的升级，升级后的 synchronized 性能可以说上了一个新台阶。</p><p>在 JDK 1.6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ol><li><p>无锁状态</p></li><li><p>偏向锁状态</p></li><li><p>轻量级锁状态</p></li><li><p>重量级锁状态</p><p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，很好理解。</p></li></ol><table><thead><tr><th align="left"><strong>锁</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td align="left">偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td align="left">轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗 CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td align="left">重量级锁</td><td>线程竞争不使用自旋，不会消耗 CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>以往的研究发现大多数情况下<strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句</strong>,CAS操作都不做了，着极大地提高了程序的运行性能。</p><p>大白话就是对锁设置个变量，如果发现为 true，代表资源无竞争，则无需再走各种加锁&#x2F;解锁流程。如果为 false，代表存在其他线程竞争资源，那么就会走后面的流程。</p><h4 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h4><p>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁依赖于操作系统的互斥锁（mutex，用于保证任何给定时间内，只有一个线程可以执行某一段特定的代码段） 实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于对象的原生锁——synchronized&lt;/p&gt;
&lt;p&gt;实际上，Java 在&lt;code&gt;java.util.concurrent&lt;/code&gt;（JUC）包下，还为我们提供了更多的锁类和锁接口（尤其是子包 locks 下），它们有更强大的功能或更牛逼的性能。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://timei.me/2024/11/16/Redis/"/>
    <id>https://timei.me/2024/11/16/Redis/</id>
    <published>2024-11-16T01:31:13.000Z</published>
    <updated>2024-12-02T12:16:59.656Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、<strong>缓存</strong>和消息中<br>间件。 它支持多种类型的数据结构</p><h3 id="缓存（Cache）的概念"><a href="#缓存（Cache）的概念" class="headerlink" title="缓存（Cache）的概念"></a>缓存（Cache）的概念</h3><p>缓存是存储在计算机上的一个原始数据复制集，以便于访问。</p><p><img src="https://imgs.cloves.top/2024/12/c0ebffe5911879e22cc2c7c0c18c0cf8.png" alt="img-缓存的概念"></p><h3 id="缓存命中率的一些概念"><a href="#缓存命中率的一些概念" class="headerlink" title="缓存命中率的一些概念"></a>缓存命中率的一些概念</h3><p><img src="https://imgs.cloves.top/2024/12/78407704303ec5ec7ddd9f43bc94981c.png" alt="img-cache"></p><h3 id="Redis的命令"><a href="#Redis的命令" class="headerlink" title="Redis的命令"></a><strong>Redis的命令</strong></h3><ul><li>指定database  select 0</li></ul><h4 id="操作Key"><a href="#操作Key" class="headerlink" title="操作Key"></a>操作Key</h4><ul><li>exists 查询key是否存在</li><li>keys 查询是否存在指定的key</li><li>type 查询key的数据类型</li><li>scan 扫描当前库中所有的key</li></ul><h4 id="操作String"><a href="#操作String" class="headerlink" title="操作String"></a>操作String</h4><ul><li>set :添加一条String类型数据</li><li>get :获取一条String类型数据</li><li>mset :添加多条String类型数据</li><li>mget :获取多条String类型数据</li><li>incr :增加1</li><li>decr：减少1</li></ul><h4 id="操作hash"><a href="#操作hash" class="headerlink" title="操作hash"></a>操作hash</h4><ul><li>hset :添加一条hash类型数据</li><li>hget :获取一条hash类型数据</li><li>hmset :添加多条hash类型数据</li><li>hmget :获取多条hash类型数据</li><li>hgetAll :获取指定所有hash类型数据</li><li>hdel :删除指定hash类型数据(一条或多条)</li></ul><h4 id="操作list"><a href="#操作list" class="headerlink" title="操作list"></a>操作list</h4><ul><li><p>lpush :左添加(头)list类型数据</p></li><li><p>rpush :右添加(尾)类型数据</p></li><li><p>lrange : 获取list类型数据start起始下标 end结束下标 包含关系</p></li><li><p>llen :获取条数</p></li><li><p>lrem :删除列表中几个指定list类型数据</p><ul><li><pre><code class="TEXT">lrem key count valuecount &gt; 0 从前向后删除count个valuecount &lt;0 从后向前删除 绝对值（count） 个valuecount = 0 删除所有的value</code></pre></li></ul></li></ul><h4 id="操作set"><a href="#操作set" class="headerlink" title="操作set"></a>操作set</h4><ul><li>sadd :添加set类型数据</li><li>smembers :获取set类型数据</li><li>scard :获取条数</li><li>srem :删除数据</li></ul><h4 id="操作sorted-set"><a href="#操作sorted-set" class="headerlink" title="操作sorted set"></a>操作sorted set</h4><p>sorted set是通过分数值来进行排序的，分数值越大，越靠后。</p><ul><li><p>zadd :添加sorted set类型数据</p><p>zadd需要将Float或者Double类型分数值参数，放置在值参数之前</p></li><li><p>zrange :获取sorted set类型数据</p></li><li><p>zcard :获取条数</p></li><li><p>zrem :删除数据</p></li></ul><h4 id="操作namespace"><a href="#操作namespace" class="headerlink" title="操作namespace"></a>操作namespace</h4><ul><li><p>mset 添加数据   例  mset user:01 zhangsan</p></li><li><p>mget 获取数据    例 mget  user:01</p></li></ul><h4 id="操作失效时间"><a href="#操作失效时间" class="headerlink" title="操作失效时间"></a>操作失效时间</h4><ul><li><p>EXPLRE 简写 EX  ex &lt;key&gt; &lt;ttl&gt;  用于生成键的同时设置生存时间（秒）</p><p>例 set  code test EX 180</p></li><li><p>PEXPIRE &lt;key&gt;  &lt;ttl&gt; 可以将 已有的键 key 的过期时间设置为 <strong>毫秒</strong> 不加 P 是秒</p><p>例  pexpire  code 1000</p></li><li><p>NX 是key不存在时才set，防止覆盖    XX 是key存在时才set，不创建新的key</p><p> EX 是秒， PX 是毫秒     例 set  code  test  nx  ex 180</p></li></ul><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><ul><li>del :用于删除数据（通用，适用于所有数据类型）</li><li>hdel :用于删除hash类型数据</li></ul><h3 id="Redis的事务机制"><a href="#Redis的事务机制" class="headerlink" title="Redis的事务机制"></a>Redis的事务机制</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程<br>中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h4 id="事务的操作命令"><a href="#事务的操作命令" class="headerlink" title="事务的操作命令"></a>事务的操作命令</h4><p>Multi、Exec、discard</p><p>输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行。<br>输入Exec后，Redis会将之前的命令队列中的命令依次执行。<br>组队的过程中可以通过discard来放弃组队。</p><h4 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h4><p>组队阶段某个命令出现了报告错误，执行时整个的所有队列会都会被取消。<br>执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><h3 id="Redis的高可用"><a href="#Redis的高可用" class="headerlink" title="Redis的高可用"></a>Redis的高可用</h3><p>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群。</p><h4 id="数据的持久化（数据落盘）"><a href="#数据的持久化（数据落盘）" class="headerlink" title="数据的持久化（数据落盘）"></a>数据的持久化（数据落盘）</h4><h5 id="RDB-Redis-DataBase"><a href="#RDB-Redis-DataBase" class="headerlink" title="RDB(Redis DataBase)"></a>RDB(Redis DataBase)</h5><p>  会损失较长时间的数据（分钟级别）</p><h5 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h5><p>  会损失1秒钟的数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、&lt;strong&gt;缓存&lt;/strong&gt;和消息中&lt;br&gt;间件。 它支持多种类型的数据结构&lt;/p&gt;
&lt;h3 id=&quot;缓存（Cache）的概念&quot;&gt;&lt;a href=&quot;#缓存（Cache）的概念&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://timei.me/2024/11/15/hello-world/"/>
    <id>https://timei.me/2024/11/15/hello-world/</id>
    <published>2024-11-15T14:11:23.805Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
